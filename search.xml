<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[对抗反编译之使用密码表来保护代码中的字符串]]></title>
    <url>%2F2018%2F07%2F13%2Fpassword-table%2F</url>
    <content type="text"><![CDATA[对抗反编译之使用密码表来保护代码中的字符串在最近几个月的时间内，由于工作的关系，一直在对抗互联网的黑色产业，就是传说中的众多刷机工作室。他们拥有数量众多的越狱设备，只要有利可图，就会对目标ipa进行破解来达到获利的目的。 众所周知，苹果设备和app的安全性要比隔壁安卓高出许多，但这个是在有苹果爸爸设计的一系列安全保护措施下面，也就是在非越狱环境下。一旦app跑在越狱的环境下，并且开发者没有做任何保护措施的话，那就相当于裸奔了。 安全这个问题很大，我仅分享给大家工作中我学到的经验，之后我会一点一点更新我的blog，如果有更多时间，还有开源一些代码到我的github上。今天先来谈谈程序中字符串的安全问题。 一般程序中对敏感字符串处理的例子一般程序员因为工期赶或者没有安全性上的顾虑，对app中敏感的字符串，尤其是跟自家服务器通信的私钥啦，身份验证key啦，都是用一个全局字符串常量来保存，就跟下面代码一样： secret.h 文件1extern NSString * const secretKey; secret.m 文件1NSString * const secretKey = @&quot;nzPHmNrbjuVOO7dX&quot;; 这样做的结果是，图谋不轨的人只要利用反编译工具就能够轻而易举获得app中任意敏感信息，对公司利益造成巨大损失。有不少反编译工具可以使用，例如Hopper Disassembler, IDA Pro等工具。 如何有效防止字符串泄露敏感信息办法肯定有不少，我这里分享我们自己在用的办法。 基本想法就是预先配置好一个字符表 然后将需要隐藏的敏感信息字符串一个字符一个字符从表里查到出相应的位置记下来 程序使用的时候跟第2步的位置组成的字符数组，把字符串还原出来 代码分享 代码在iOS和android两个平台都能够使用 生成密码表假设我们现在预先配置的字符表为ABCD123456 先通过这个网站http://www.online-toolz.com/tools/text-hex-convertor.php获得这个字符串的hex code 41424344313233343536，然后在程序中声明一个数组hex_table来存储它（见下面的代码） 12345//PasswordTable.c//source string: ABCD123456static const uint8_t hex_table[TABLE_SIZE] = &#123; 0x41,0x42,0x43,0x44,0x31,0x32,0x33,0x34,0x35,0x36 &#125;; 查询并输出字符在密码表中的位置使用下面的代码可以在console看到对应的数组，将它copy下来，例如我们这里传入’BCD456’后生成对应的int数组len = 6 { 1, 2, 3, 7, 8, 9, }，把这个数组记下来。12345678910111213141516171819//PasswordTable.c/** * lookup magic numbers in terms of the given str based * on magic table. */void lookupMagics(const char * str, size_t str_len)&#123; printf("len = %li &#123;", str_len); for (int j = 0; j &lt; str_len; j++) &#123; for (int i = 0; i &lt; TABLE_SIZE; i++) &#123; if (hex_table[i] == str[j]) &#123; printf(" %i,", i); break; &#125; &#125; &#125; printf(" &#125;\n");&#125; 从密码表生成原字符串123456789101112131415//PasswordTable.h#define TABLE_SIZE 10/** Convert integer array to string based on built-in hex table. @param array integer array. @param arr_len length of the array. @param buffer string buffer for receiving result, make sure it was alloced. @param buffer_len length of the buffer. @return 0 success, -1 if buffer_len is less than arr_len. */int convertMagics2String(int * array, size_t arr_len, char * buffer, size_t buffer_len); 12345678910111213141516171819202122232425262728//PasswordTable.c//source string: ABCD123456static const uint8_t hex_table[TABLE_SIZE] = &#123; 0x41,0x42,0x43,0x44,0x31,0x32,0x33,0x34,0x35,0x36 &#125;;int convertMagics2String(int * array, size_t arr_len, char * buffer, size_t buffer_len)&#123; if (buffer_len &lt;= arr_len) &#123; return -1; &#125; memset((void *)buffer, 0, arr_len + 1); for (int i = 0; i &lt; arr_len; i++) &#123; buffer[i] = hex_table[array[i]]; &#125; return 0;&#125;//main.c#include "PasswordTable.h"int main() &#123; int magics[] = &#123;1, 2, 3, 7, 8, 9&#125;;//之前由调用lookupMagics生成的整形数组 char str[7]; convertMagics2String(magics, 6, str, 7); printf("the source string is %s\n", str); //将会打印: the source string is BCD456 return 0;&#125; 在上面代码中main函数的例子就是你在实际代码中的样子。这样做了以后，反编译工具就很难快速容易地通过字符串获得关键信息了，除非对方对你的代码抱有极大的兴趣，愿意花时间分析。 最后再多说一点，为了进一步加强安全性，建议对以上c函数进行混淆，将进一步加大反编译分析的难度。]]></content>
      <categories>
        <category>逆向工程</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>android</tag>
        <tag>逆向工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Fastlane和Jenkins构建自动打包系统 (Part 2)]]></title>
    <url>%2F2018%2F07%2F02%2Fjenkins-fastlane-part2%2F</url>
    <content type="text"><![CDATA[Fastlane match 使用已经存在的证书经过第一部分的学习，Fastlane这个工具确实很好用，自动生成证书，自动打包，自动传到appstore，一切看上很完美。但是，在默认情况下，match是不能够使用已经存在的证书和provisiong profiles的，换句话说就是每次调用fastlane match的时候，如果发现git repo没有就会为你生成新的。显然，这个限制会让很多现有项目的开发者望而生畏。好在，我们有办法可以让它支持现有证，但是这个办法稍微有点麻烦，因为它不是自动的。 如果你还未了解什么是fastlane，请先阅读使用Fastlane和Jenkins构建自动打包系统 (Part 1) 导出证书在我们开始使用现有的证书前，先得保证所有需要的证书和私钥都已经被导出并且保存在本地。 首先 打开keychain, 选择要将要在项目中使用的证书，然后选择导出 在File Format选择导出为.cer文件。 然后，再次选择导出，在File Format选择导出为p12导出私钥（不要设置密码，因为如果设置了密码后，fastlane就无法导入私钥了）。 下一步就是去查找证书在apple developer portal的id了（后续需要以这个id来为证书和私钥命名），但是这个信息在管理后台是看不到的。这个时候，就需要借助fastlane内部直接使用的一个库Spaceship。 使用Spaceship在命令行输入irb打开一个交互式的ruby shell环境。 之后，输入require &#39;spaceship&#39;和回车，这个命令会将这个库导入到当前的shell环境中。接下来，输入下面这个命令来登录到apple developer portal： 1Spaceship.login 然后就是获取证书信息的命令，这里有两种方式，一种是获得全部的，另外一种是按照证书的类型来获取。 第一种，获取所有证书信息： 1Spaceship.certificate.all 第二种，获取指定类型的证书信息： 获取开发证书 1Spaceship.certificate.development.all 获取发布证书 1Spaceship.certificate.production.all 证书信息例子： 1234567891011&lt;Spaceship::Portal::Certificate::Development id="TB48U5GPM8", name="iOS Development", status="Issued", created=2018-06-29 10:35:08 UTC, expires=2019-06-29 10:25:08 UTC, owner_type="teamMember", owner_name="owner name", owner_id="X9EZKD2K8B", type_display_id="6QPB9NHCEX", can_download=true&gt; 这个命令会列出证书所有的信息，而且很有可能会返回多个证书。这个时候，你需要仔细将其与本地证书的时间和过期对比，一致的就是你要找的证书信息。当你找到匹配的，就以证书信息的id来命名本地保存的相应的证书和私钥。 接下来我们需要将证书push到match使用的git repo上。 Push 证书和Provision在命令行输入下面的命令来准备一些需要用到的变量： 123456789irb(main):004:0&gt; require 'match'=&gt; trueirb(main):005:0&gt; git_url='git@github.com:path-to/the-encrypted-certs-repo.git'=&gt; "git@github.com:path-to/the-encrypted-certs-repo.git"irb(main):006:0&gt; shallow_clone = false=&gt; falseirb(main):007:0&gt; manual_password = 'password-to-decrypt-the-repo'=&gt; "password-to-decrypt-the-repo"irb(main):008:0&gt; 接下来，我们需要使用下面的命令把存放证书的git repo给clone下来并且解密 1234irb(main):005:0&gt; workspace = Match::GitHelper.clone(git_url, shallow_clone, manual_password: manual_password)[21:17:30]: Cloning remote git repo...[21:17:31]: 🔓 Successfully decrypted certificates repo=&gt; "/var/folders/5s/5cgmqxkx4fx6bllwgp1y5dlh000gp/T/d2018-0411-3701-148akjh" 这个命令将repo clone到了/var/folders/...打开它。然后在这个文件夹里面，根据证书的类型来创建不同的文件夹： 如果创建开发证书，则放到certs/development里面 如果是发布证书，则放到certs/distribution里面 将证书和私钥都要对应放到上述的文件夹里面。 最后来处理provision profiles，首先你得从Apple developer portal下载所需要的provision profiles。下载完成后，根据不同的类型放入不同的文件夹，规则如下： adhoc: profiles/adhoc/AdHoc_&lt;appbundleid&gt;.mobileprovision appstore: profiles/appstore/AppStore_&lt;appbundleid&gt;.mobileprovision development: profiles/development/Development_&lt;appbundleid&gt;.mobileprovision 做完这些后，现在我们来把证书和provision profiles推到git repo上去吧。执行下面的命令： 1irb(main):006:0&gt; Match::GitHelper.commit_changes(workspace, "add certificate, private key and provisioning profiles", git_url) 大功告成。现在你应该可以通过fastlane命令来安装证书和provision profiles了。 1fastlane match development --readonly]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Fastlane和Jenkins构建自动打包系统 (Part 1)]]></title>
    <url>%2F2018%2F06%2F23%2Ffastlane-jenkins%2F</url>
    <content type="text"><![CDATA[发这篇博文的目的主要是总结一些在使用fastlane过程遇到的坑，顺便吐槽一下Fastlane官方网站：写的好飘逸，对于新手来说不看几遍不试几次，完全不知到整个体系是如何的。。。最后我希望能够帮助看到这篇文章的你:] Fastlane Fastlane是一种能够将iOS和android平台beta测试或者正式发布完全自动化的工具！It’s amazing dude! 它能够做的事情有： 生成应用商店需要的所有截图 (本地化的截图！可以根据需要为各种语言生成） 处理打包时候的签名 发布应用到商店 我们接下来以iOS为例讲解如何使用fastlane打包iOS app fastlane初始化配置详细的setup步骤这里不赘述，大家可以到Getting started with fastlane for iOS查看。 根据文档，安装完fastlane后，配置工程的第一个命令是(这里不建议使用swift版本的init，一个是目前是beta版本，另外一个是当前能查到的资料都是以ruby DSL来说明的): 1fastlane init 运行这个命令之后，会看到命令行出现交互式提问，第一个问题经常是问你想用fastlane 来干嘛？ 12341. 📸 Automate screenshots (自动化appstore 本地化截图)2. 👩‍✈️ Automate beta distribution to TestFlight (自动化发布beta测试app到test flight)3. 🚀 Automate App Store distribution (appstore 发布自动化)4. 🛠 Manual setup - manually setup your project to automate your tasks (手动配置自己的工程) 如果您的app有多个target或者没有找到跟workspace名字一样的scheme，fastlane会提示输入bundle id，然后会提示输入apple id及其密码，如果apple id在多个team还会提示选择team等等，总之问题问完，你的初始配置也就完成了。 配置完后，会在您的工程下面生成一个名为fastlane的文件夹，这个文件夹就是所有fastlane的配置所在了。文件夹会包含两个文件: Appfile: 用来存储在使用fastlane过程中所需要的有用信息，例如apple id，bundle id等 Fastfile: fastlane编译以及发布的核心文件，所有需要自动编译配置的代码都放到这个文件里面 Fastfile现在重点讲一下如何配置Fastfile。初始化完后，fastlane会自动为工程生成如下代码在fastfile里面(我在初始化的时候选择的是第3项–appstore发布自动化，如果选择别的选项可能会与下面的例子有稍微不同)。 1234567platform :ios do desc "Push a new release build to the App Store" lane :release do build_app(workspace: "Spacename.xcworkspace", scheme: "SchemeName") upload_to_app_store(skip_metadata: true, skip_screenshots: true) endend platform: 告诉fastlane是哪个平台。 desc: 注解。一般放到每个lane之前一行用于解释这个lane的作用 lane: 简单来讲就是一个任务的配置，比如发布到test flight算一个任务，打内部测试Adhoc包等。lane 后面跟着的是冒号加任务名称，如上代码： :release, 这样你就可以在命令行下面输入如下命令就可以执行这个任务了： 1fastlane release lane的body里面能够使用的命令都叫做action，能调用的actions官方已经帮我们列出来了，而且每个action都有详细的文档。例子中的任务一眼就能看出来是做什么：编译名为Spacename.xcworkspace，scheme为SchemeName的工程，编译完后上传到app store（跳过上传meta data和screenshots） 读者可以亲手试一试，讲workspace和scheme改为自己工程的名字，然后在命令行运行fastlane release，之后如果编译没有失败并且itunes connect连接和验证成功的话，您会看到ipa包已经成功的传到了itunes connect的后台了。怎么样？很厉害吧，就2行代码就搞定了编译，打包，上传到appstore这种平时繁杂的任务！ 等等，我们好像漏了什么。对，最重要的程序签名！ Fastlane match什么是Fastlane match? Fastlane match不仅仅是在配置fastlane自动打包时候需要用到，而且极大地简化了在一个开发团队中共享证书和provisioning profiles的流程！ 项目组中每来一个新成员，是不是都要花时间为新成员配置证书，并且把他加入到相应项目的provisioning profiles里面？如果项目众多，是不是管理的一场噩梦？想要简化吗？快使用Fastlane match! 连接到苹果服务器很慢，下载provisioning profile很慢！想每次都下载快吗？快使用Fastlane match! 想在团队中方便的使用个人开发者证书，而不用拷来拷去吗？快使用Fastlane match! 项目组有新设备后，快使用Fastlane match! 一键搞定！ 说了那么多好处，咱们来看看怎么用！首先在工程所在文件夹运行如下命令（确保在运行之前先运行过fastlane init命令） 1fastlane match init 运行完后，fastlane会问用来存储工程的证书和provisioning profiles的Git repo的URL是什么？所以，马上去Github或者Gitlab上创建一个去吧！ 注意！！！ 所有传到指定git repo的证书和provisioning profiles将会被fastlane使用OpenSSL来加密存储的。 你必须对曾git repo有完全的控制权力。最好保证你所使用的git repo是私有的并且使用安全的私钥。 即使你的证书泄露了，在不知道你的itunes connect账号的情况下并不能对你造成伤害 如果你使用Git hub或者Bitbuckt，建议你使用开启两步验证的itunes connect账号来作为match连接时用的账号 跟随着所有提示做完后会在fastlane文件夹下生成一个叫做Matchfile的文件，初始的文件内容与下面类似： 1234567891011git_url("git@xxx/certificates.git")type("development") # The default type, can be: appstore, adhoc, enterprise or developmentapp_identifier(["bundle identifier 1", "bundle identifier 2"])#username("xxx@xxx.com") # Your Apple Developer Portal username# For all available options run `fastlane match --help`# Remove the # in the beginning of the line to enable the other options#match(app_identifier: ["bundle identifier 1", "bundle identifier 2"], type: "adhoc") 初始化完后，就到为工程生成证书和provisioning profiles了 ，（如果不是新项目，想利用已经存在的证书怎么办？这部分也有解决方案，我打算放到part 2的时候再讲）运行如下命令，就会为工程生成development证书和相应的provisiong profile： 1fastlane match development 第一次运行这个命令会提示请输入passphase，这个passphase就是用来加密证书和provisioning profiles用的。 注意: 运行以上命令,如果发现没有相应的证书和provisiong profiles就会生成新的证书和provisioning profiles，所以请慎用！ 接下来，如果想在一台新的机器上安装该工程的证书就可以运行下面的命令： 1fastlane match development --readonly 加上–readonly就能保证不会生成新的，而仅仅只是执行安装而已。除了development,我们还能指定adhoc, appstore, enterprise等参数来生成不同场景的证书。 生成的证书和provisioning profiles都会被加密放到初始化match时指定的git repo中，这样当使用fastlane match development或者fastlane match development –readonly的时候，fastlane会第一时间从指定的git repo中去寻找并安装，所以不需要经过苹果服务器。如果git repo是自己公司服务器的，那就更快了:]。 如果想一口气装上所需要的证书和provisioning profiles, 那么可以写一个脚本来完成： 1234567#!/bin/sh#install appstore development profiles and certfastlane match development --readonly#uncomment below lines if you need install other types of certs#fastlane match adhoc --readonly#fastlane match appstore --readonly 将脚本传到工程git上，这样只要有新机器，就运行一下这个脚本就全部装上了。 在Fastfile中使用match配置好match后，如何在fastfile中使用呢？其实很简单，如下： 12345678platform :ios do desc "Push a new release build to the App Store" lane :release do sync_code_signing build_app(workspace: "Spacename.xcworkspace", scheme: "SchemeName") upload_to_app_store(skip_metadata: true, skip_screenshots: true) endend 只需要在编译之前调用sync_code_signing即可！]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[敏捷设计之SOLID原则]]></title>
    <url>%2F2017%2F08%2F24%2Fagile-desgin%2F</url>
    <content type="text"><![CDATA[敏捷设计之SOLID原则把握所学东西的本质在讨论SOLID原则之前，我们需要明确一点，就是这个规则是为了解决什么问题而被发明出来的。只有弄清楚这一点，才能够在实际工作中正确应用。举个栗子吧，比如为什么要采用MVC？教科书般的回答就是MVC就是Model-View-Controller，然后将Model,View和Controller各自按照教科书说一遍。你觉得你真的理解为什么要用MVC了吗？举个简单的例子说明非MVC是什么样的吧？ 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;%set conn=Server.CreateObject("ADODB.Connection")conn.Provider="Microsoft.Jet.OLEDB.4.0"conn.Open(Server.Mappath("/db/northwind.mdb"))set rs = Server.CreateObject("ADODB.recordset")rs.Open "Select * from Customers", conndo until rs.EOF for each x in rs.Fields Response.Write(x.name) Response.Write(" = ") Response.Write(x.value &amp; "&lt;br&gt;") next Response.Write("&lt;br&gt;") rs.MoveNextlooprs.closeconn.close%&gt;&lt;/body&gt;&lt;/html&gt; 这是一段ASP classic的代码。这段代码的问题： 无法在类似逻辑的页面重用使用数据库的代码。为了满足快速迭代的需求，将会促使程序员自然而然的使用copy-paste大法。 页面的显示与数据库代码混在一起，如果需求变化，要调整页面显示将会变得很麻烦。一个页面还好，如果是几十个这种代码的页面呢？ 所以，从如何能够让这段代码重用为出发点，MVC在不断的试验与测试中诞生了。MVC的优点总结请自行Google。 设计臭味设计一个软件的结构或者架构的时候，如果没有足够的经验，经常会产生如下问题: 僵化性僵化性是指对软件进行改动，即使是简单的改动。如果单一的改动会导致有依赖关系的模块中的连锁改动，那么设计就是僵化的。 脆弱性脆弱性是指，在进行一个改动时，可能会导致程序的许多地方出现问题。 顽固性顽固性是指，设计中包含了对其他有用的部分，但是要把这些部分从系统中分离出来所需要的努力和风险却是巨大的，这是一种令人遗憾，但非常常见的情况。 粘滞性粘滞性是指，当面临一个改动时，开发人员尝尝发现有多种改动的方法。其中，有一些会保持敏捷设计，而另外一些则会破坏设计。比如，如果编译所花费的时间很长，那么开发人员就会被诱导去做不会导致大规模编译的举动。 不必要的复杂性如果设计中包含了当前没用的组成部分，它就含有不必要的复杂性。当开发人员预测需求的变化，并在软件中放置了处理潜在变化的代码时，尝尝出现这种情况。起初，这样做看起来貌似是一件好事，但是结果尝尝正好相反。为过多的可能性做准备，致使设计由于含有绝不会用到的结构而变得混乱。 不必要的重复性copy-paste 晦涩性晦涩性是指模块难以理解。 怎么能尽量避免产生以上问题呢？那就需要借鉴敏捷设计。 敏捷设计原则之SOLID大家都听说过敏捷开发宣言， 其中最后一条是”随时应对变化重于遵循计划”。要达这目的并且避免写出有臭味的代码，就需要引入敏捷设计，就是要让自己的代码够“敏捷”。我认为只有代码具有敏捷设计思想，敏捷开发宣言所倡导的才能够顺利实现。打个比喻，中国古代打战有许多排兵布阵的阵法，想想看如果使用的是一个玄妙无比的阵法，比如八卦阵，但是执行阵法的士兵大部分都是老弱残兵以及老幼妇孺，恐怕连阵势都摆不出来就战败了吧。我们这里说的敏捷设计原则就像士兵一样，是基石。 那到底什么是敏捷设计呢？敏捷设计是一个过程，不是一个事件。它是一个持续的应用原则、模式以及实践来改进软件的结构和可读性的过程。它致力于保持系统在任何事件都尽可能的简单干净以及富有表达力。 接下来，我们学习敏捷设计原则，但请记住，敏捷开发人员不会把这些原则应用到一个庞大的预先设计中。相反，这些原则被应用在一次次的迭代中，力图使代码以及代码所表达的设计保持干净。 单一职责原则(SRP) 一个类应该只有一个发生变化的原因 如果一个类承担的职责过多，就等于把这些职责耦合在了一起。一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。 考虑下图的设计： 这个设计违反了SRP，显然Rectangle有两个职责。导致的问题： 打包到GUI程序中的时候，需要将计算机几何应用库与图形绘制应用库一起打包 如果依赖的任何一个库发生了改变，则需要重新对程序打包。如果忘记做，而仅仅只是更新其中一个库的话，将会导致不可预料的错误。 改进： 开放关闭原则(OCP) 一个类对修改关闭，对扩展开放。具体来说就是，一个类在不修改它本身的代码的前提下允许扩展它的行为(如果不修改做不到到话，尽量把修改做到最小化) OCP 听起来并不复杂，但是却不是那么容易实践的。因为通常情况下，为一个功能而设计可以对未来需求开放的类并不简单。这里重要的点是未来需求。当我们并不知道未来软件的需求的时候，我们将怎样设计类，模块，功能等来迎合需求呢？这就是OCP不容易实践的原因，通常需要彻底的思考设计。 我们该如何去解决这个问题呢？当设计类结构的时候，需要用心确类的扩展简单。设计阶段，将所有类的用例记下来，并对所有用例给出合适的接口。抽象类是一种能够确保类能够被扩展的手段，但是要小心不要违反SRP，当想让一个类做更多事情的时候就很容易发生。 例子该例子是一个计算个人所得税的例子。 12345678910111213141516171819202122232425262728293031323334353637class Individual: NSObject &#123; let salary : Double; let age : NSInteger; let name : String; let countryCode : String; init(salary : Double, age : NSInteger, name : String, countryCode : String) &#123; self.countryCode = countryCode; self.salary = salary; self.age = age; self.name = name; &#125;&#125;class TaxCalculator : NSObject &#123; public func calculate(_ individual : Individual) -&gt; Double &#123; var tax : Double; //Just use flat calculation algorithm for simplicity as //here we just use it to demostrate OCP. switch individual.countryCode &#123; case "cn": tax = individual.salary * 0.18; case "us": tax = individual.salary * 0.20; case "jp": tax = individual.salary * 0.50; default: tax = 0.1; &#125; return tax; &#125;&#125; 现有设计的缺点现有设计的缺点很明显，如果我们想要增加一个新的国家的个税计算，则一定需要更改现有的TaxCalculator的代码。显然，当前设计不对扩展开放。 一个更好的符合OCP的设计123456789101112131415161718192021222324252627protocol CalculateTax &#123; func calculate(_ individual : Individual) -&gt; Double;&#125;class ChinaTaxCalculator: NSObject, CalculateTax &#123; public func calculate(_ individual: Individual) -&gt; Double &#123; return individual.salary * 0.18; &#125;&#125;class USATaxCalculator: NSObject, CalculateTax &#123; public func calculate(_ individual: Individual) -&gt; Double &#123; return individual.salary * 0.20; &#125;&#125;class JapanTaxCalculator: NSObject, CalculateTax &#123; public func calculate(_ individual: Individual) -&gt; Double &#123; return individual.salary * 0.50; &#125;&#125;class TaxCalculator: NSObject &#123; public func calculate(taxHandler : CalculateTax, individual : Individual) -&gt; Double &#123; return taxHandler.calculate(individual); &#125;&#125; 现在，如果增加一个国家的税收计算，只需要添加一个相应国家的税收计算类XXTaxCalculator即可，并不需要更改任何已有代码。如果项目按照以下划分程序依赖库的结构，则只需要重新编译具体实现了各个国家税收的库就行了。 Liskov替换原则(LSP) Liskov 替换原则说的是如果D是B的派生类，则任何B的应用都必须能够被D的实例替换而不会影响到程序运行的逻辑或者功能。换句话说，就是派生类必须能够完全替换基类。 我们先看一个大概只要你学Liskov原则都会看到的一个违反Liskov原则的例子。 违反Liskov替换原则的例子1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Rectangle &#123; public var width : Double; public var height : Double; init(width : Double, height : Double) &#123; self.width = width; self.height = height; &#125; func area() -&gt; Double &#123; return self.width * height; &#125;&#125;class Square : Rectangle &#123; fileprivate var _width : Double = 0; fileprivate var _height : Double = 0; override public var width: Double &#123; get &#123; return _width; &#125; set(newWidth) &#123; _width = newWidth; _height = newWidth; &#125; &#125; override public var height: Double &#123; get &#123; return _height; &#125; set (newHeight) &#123; _width = newHeight; _height = newHeight; &#125; &#125;&#125;func createRectangle(width : Double, height : Double) -&gt; Rectangle &#123; return Square(width: width, height: height);&#125;///////////////////////////////////////////////////////////////////////Someday we use createRectangle method somewhere in our application.var rect:Rectangle = createRectangle(width : 3, height : 3);rect.area();//result is 9 as expectedrect.height = 10;rect.width = 5;rect.area();//opps!result is 25 not 50! 结论这个原则是对OCP的一个扩展，他告诉我们从基类派生出新的派生类的时候，我们必须保证不要破坏原有的行为。 接口隔离原则(ISP) 接口隔离原则讲的是接口实现者不能被强迫实现或者依赖一些不会用到的方法 举个例子，当我们将一个模块从应用程序中抽象出多个子模块的时候需要小心注意了。假设这个模块是基于类实现的，那我们能够从类抽象出接口（注：这些接口都会在现有系统被逐一实现）。但当我们把模块加入到一个与原系统相比仅含有某些接口的实现，有可能会发生这种结果：为了保证模块能够正常运行，不得不在新系统中被迫实现所有的接口并且有相当一部分接口不会被用到，这部分不会被用到的接口通常为空实现或者返回虚假值，就为了实现接口而实现。通常发生这种情况的接口叫做胖接口或者被污染的接口。 一个违反了ISP的实际例子在早期的ASP.NET 2.0版本中，如果网站想实现自己的membership provider，则需要将需要或者不需要的所有接口都实现一遍。如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149public class CustomMembershipProvider : MembershipProvider&#123; public override string ApplicationName &#123; get &#123; throw new Exception("The method or operation is not implemented."); &#125; set &#123; throw new Exception("The method or operation is not implemented."); &#125; &#125; public override bool ChangePassword(string username, string oldPassword, string newPassword) &#123; throw new Exception("The method or operation is not implemented."); &#125; public override bool ChangePasswordQuestionAndAnswer(string username, string password, string newPasswordQuestion, string newPasswordAnswer) &#123; throw new Exception("The method or operation is not implemented."); &#125; public override MembershipUser CreateUser(string username, string password, string email, string passwordQuestion, string passwordAnswer, bool isApproved, object providerUserKey, out MembershipCreateStatus status) &#123; throw new Exception("The method or operation is not implemented."); &#125; public override bool DeleteUser(string username, bool deleteAllRelatedData) &#123; throw new Exception("The method or operation is not implemented."); &#125; public override bool EnablePasswordReset &#123; get &#123; throw new Exception("The method or operation is not implemented."); &#125; &#125; public override bool EnablePasswordRetrieval &#123; get &#123; throw new Exception("The method or operation is not implemented."); &#125; &#125; public override MembershipUserCollection FindUsersByEmail(string emailToMatch, int pageIndex, int pageSize, out int totalRecords) &#123; throw new Exception("The method or operation is not implemented."); &#125; public override MembershipUserCollection FindUsersByName(string usernameToMatch, int pageIndex, int pageSize, out int totalRecords) &#123; throw new Exception("The method or operation is not implemented."); &#125; public override MembershipUserCollection GetAllUsers(int pageIndex, int pageSize, out int totalRecords) &#123; throw new Exception("The method or operation is not implemented."); &#125; public override int GetNumberOfUsersOnline() &#123; throw new Exception("The method or operation is not implemented."); &#125; public override string GetPassword(string username, string answer) &#123; throw new Exception("The method or operation is not implemented."); &#125; public override MembershipUser GetUser(string username, bool userIsOnline) &#123; throw new Exception("The method or operation is not implemented."); &#125; public override MembershipUser GetUser(object providerUserKey, bool userIsOnline) &#123; throw new Exception("The method or operation is not implemented."); &#125; public override string GetUserNameByEmail(string email) &#123; throw new Exception("The method or operation is not implemented."); &#125; public override int MaxInvalidPasswordAttempts &#123; get &#123; throw new Exception("The method or operation is not implemented."); &#125; &#125; public override int MinRequiredNonAlphanumericCharacters &#123; get &#123; throw new Exception("The method or operation is not implemented."); &#125; &#125; public override int MinRequiredPasswordLength &#123; get &#123; throw new Exception("The method or operation is not implemented."); &#125; &#125; public override int PasswordAttemptWindow &#123; get &#123; throw new Exception("The method or operation is not implemented."); &#125; &#125; public override MembershipPasswordFormat PasswordFormat &#123; get &#123; throw new Exception("The method or operation is not implemented."); &#125; &#125; public override string PasswordStrengthRegularExpression &#123; get &#123; throw new Exception("The method or operation is not implemented."); &#125; &#125; public override bool RequiresQuestionAndAnswer &#123; get &#123; throw new Exception("The method or operation is not implemented."); &#125; &#125; public override bool RequiresUniqueEmail &#123; get &#123; throw new Exception("The method or operation is not implemented."); &#125; &#125; public override string ResetPassword(string username, string answer) &#123; throw new Exception("The method or operation is not implemented."); &#125; public override bool UnlockUser(string userName) &#123; throw new Exception("The method or operation is not implemented."); &#125; public override void UpdateUser(MembershipUser user) &#123; throw new Exception("The method or operation is not implemented."); &#125; public override bool ValidateUser(string username, string password) &#123; throw new Exception("The method or operation is not implemented."); &#125;&#125; Holy crap! 这是一大堆东西！可能有的时候，你仅仅是想将现有的membership provider的一部分改变成自己的而已，但是你要面对的是全部实现，这就麻烦了。如果你不懂ASP.NET没关系，这里这个例子只是想展示一种违反了ISP后的结果。 一个更简单通俗的例子来说明ISP首先看代码： 123456789101112131415protocol Animal &#123; func feed();&#125;class Dog : Animal &#123; func feed() &#123; print("feed with bone"); &#125;&#125;class Snake : Animal &#123; func feed() &#123; print("feed with mice"); &#125;&#125; 随后，你注意到有些动物是宠物，有宠物的一些特性或者与人互动的方法。 12345678910111213141516171819202122232425protocol Animal &#123; func feed(); //梳理毛发 func groom();&#125;class Dog : Animal &#123; func feed() &#123; print("feed with bone"); &#125; func groom() &#123; print("grooming and dog feel comfortable"); &#125;&#125;class Snake : Animal &#123; func feed() &#123; print("feed with mice"); &#125; func groom() &#123; //ignore this method as I am not going to groom a feaking snake. &#125;&#125; 写到这里，你就发现问题了。Animal接口被污染了。在Snake类上它要求我们实现一个并不需要的方法。好的做法是把宠物相关的方法抽象出来。 123456789101112131415161718192021222324protocol Animal &#123; func feed();&#125;protocol Pet &#123; //梳理毛发 func groom();&#125;class Dog : Animal, Pet &#123; func feed() &#123; print("feed with bone"); &#125; func groom() &#123; print("grooming and dog feel comfortable"); &#125;&#125;class Snake : Animal &#123; func feed() &#123; print("feed with mice"); &#125;&#125; 依赖反转(DIP) A. High-level 模块不应该依赖 low-level 模块。两者都应该依赖于抽象B. 抽象不能依赖于具体实现。具体实现应该依赖于抽象 例子一个简单的例子，我们经常使用DAO(Database access object)来封装数据库操作的逻辑。下面这个例子，将数据库具体的类OracleConnection直接在DAO类里面了。那如果我们想把数据库换成Mysql，怎么办呢？（想想一下，有很多DAO类，里面的逻辑都很复杂很多） 123456789101112131415161718192021222324252627class OracleConnection &#123; public func open() &#123; //open database connection logic &#125; public func close() &#123; &#125;&#125;class DAO &#123; public var databaseConnection : OracleConnection; init() &#123; databaseConnection = OracleConnection(); &#125; public func commitChanges() &#123; databaseConnection.open(); //deal with data base changes databaseConnection.close(); &#125;&#125; 符合DIP的写法: 1234567891011121314151617181920212223242526272829303132333435363738394041protocol DatabaseConnection &#123; func open(); func close();&#125;class OracleConnection : DatabaseConnection &#123; public func open() &#123; //open database connection logic &#125; public func close() &#123; &#125;&#125;class MysqlConnection : DatabaseConnection &#123; public func open() &#123; //open database connection logic &#125; public func close() &#123; &#125;&#125;class DAO &#123; public let databaseConnection : DatabaseConnection; init(databaseConnection : DatabaseConnection) &#123; self.databaseConnection = databaseConnection; &#125; public func commitChanges() &#123; databaseConnection.open(); //deal with data base changes databaseConnection.close(); &#125;&#125; 咋一看，细节上可能跟Liskov要求的很像，但是请注意，DIP主要强调的是模块之间的依赖。下面用一个例子来感受一下]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>OOD</tag>
        <tag>设计模式</tag>
        <tag>敏捷开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最短路径之迪杰斯特拉算法]]></title>
    <url>%2F2017%2F07%2F28%2Falgorithm-dijstra%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137#include &lt;iostream&gt;#include &lt;fstream&gt;#include &lt;vector&gt;using std::cin;using std::cout;using std::vector;//maximum number of nodesconst int maxnum = 100;//maxWeight represents infinite largeconst int maxWeight = 99999;//////Calculate the shortest path based on dijstra algorithm.//////@param v source node index///@param n number of nodes///@param dist to save the distance between the ith node and the source node ///@param record the ith node's previous node.///@param arcs line matrixvoid dijstra(int v, int n, int *dist, int *prev, int arcs[maxnum][maxnum]) &#123; //bool array marks which node has been put to S. //S is an array that contains nodes which makes up of the shortest path. bool included[n]; for(int i = 0; i &lt; n; i++) &#123; included[i] = false; dist[i] = arcs[v][i]; //if the distance is not maxWeight, then it means there //is a line between the v and the ith node. so set the ith //node's previous to v. if(dist[i] &lt; maxWeight) &#123; prev[i] = v; &#125; else &#123; prev[i] = -1; &#125; &#125; //start from the source node v, so put it to S by default. included[v] = true; //self to self is 0. dist[v] = 0; for(int i = 1; i &lt; n; i++) &#123; int min = maxWeight; int w; //find min distance between the source node and the ith //node. the ith node must not be in S. for(int j = 0; j &lt; n; j++) &#123; if(!included[j] &amp;&amp; dist[j] &lt; min) &#123; min = dist[j]; w = j; &#125; &#125; //put the w node into the S. included[w] = true; for(int j = 0; j &lt; n; j++) &#123; if(!included[j] &amp;&amp; min + arcs[w][j] &lt; dist[j]) &#123; dist[j] = min + arcs[w][j]; prev[j] = w; &#125; &#125; &#125;&#125;int main() &#123; std::ifstream ifin; //number of nodes int n; //number of lines int lines; int arcs[maxnum][maxnum]; ifin.open("sample.txt"); if(ifin.is_open()) &#123; ifin &gt;&gt; n; ifin &gt;&gt; lines; for(int i = 0; i &lt; lines; i++) &#123; int row, column, weight; ifin &gt;&gt; row &gt;&gt; column &gt;&gt; weight; arcs[row][column] = weight; &#125; &#125; else &#123; cout &lt;&lt; "could not open sample.txt " &lt;&lt; std::endl; return 0; &#125; ifin.close(); cout &lt;&lt; n &lt;&lt; " nodes " &lt;&lt; std::endl; cout &lt;&lt; lines &lt;&lt; " lines " &lt;&lt; std::endl; //to save the distance between the ith node and the source node int dist[n]; //to record the ith node's previous node. int prev[n]; //init arcs for(int i = 0; i &lt; n; i++) &#123; for(int j = 0; j &lt; n; j++) &#123; if(arcs[i][j] == 0) &#123; arcs[i][j] = maxWeight; &#125; cout &lt;&lt; arcs[i][j] &lt;&lt; "\t"; &#125; cout &lt;&lt; std::endl; &#125; const int v = 0; dijstra(v, n, dist, prev, arcs); cout &lt;&lt; "distance between "&lt;&lt; v &lt;&lt;" and last point is :" &lt;&lt; dist[n-1] &lt;&lt; std::endl; cout &lt;&lt; "shortest path is ["; int k = n - 1; vector&lt;int&gt; path(1,k); while(prev[k] &gt;= 0) &#123; k = prev[k]; path.push_back(k); &#125; for(vector&lt;int&gt;::reverse_iterator iter = path.rbegin(); iter != path.rend(); ++iter) &#123; cout &lt;&lt; *iter &lt;&lt; " "; &#125; cout &lt;&lt; "]" &lt;&lt; std::endl; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[找出不包含某个字符串的正则表达式]]></title>
    <url>%2F2017%2F07%2F23%2Ffind-non-include-regex%2F</url>
    <content type="text"><![CDATA[找出不包含某个字符串的正则表达式经常我们会遇到想找出不包含某个字符串，例如”hello”的文本，最容易想到的是在正则表达式里使用[^hello]，但这样的正则表达式完全是另外一个意思，它的意思是字符串里不能包含’h’，’e’，’l’, ‘o’四个单字符。那什么样的正则表达式能过滤出不包含完整“hello”字串的信息呢？事实上，说正则表达式里不支持逆向匹配并不是百分之百的正确。 我们就可以使用否定式查找来模拟出逆向匹配，从而解决我们的问题, 表达式如下： 1^((?!hello).)*$ 上面这个表达式就能过滤出不包含‘hello’字串的信息。 先解释一下?!的用法： 零宽负向先行断言(?!exp)，只会匹配后缀exp不存在的位置。例如，\d{3}(?!\d)匹配三位数字，而且这三位数字的后面不能是数字 现在解释表达式((?!hello).)*： 表达式(?!hello).会往前查找，看看前面是不是没有“hello”字串，如果没有(是其它字符)，那么.(点号)就会匹配这些其它字符。这种正则表达式的“查找”也叫做“zero-width-assertions”(零宽度断言)，因为它不会捕获任何的字符，只是判断。 我们来看一下“Nonnullhelloworld”这个字符串。 (?!hello)会检查每个字符串后面跟的是不是‘hello’，如果不是，.就匹配这个字符。表达式(?!hello)只执行一次，所以将这个表达式用括弧包裹组成组，然后用星号*修饰来匹配零次或多次。 匹配Nonnullhelloworld返回false, 说明该字符串含有‘hello’子串。匹配Nonnullworld返回true匹配Nonnullworldhello返回false匹配hello返回false 所以，你可以认为当表达式返回false的时候，说明该字符串包含指定子串。 最后推荐一个好的，快速的测试正则表达式的在线网站，我用起来很不错(居然还有正则表达式的解释，真是有点强大哈，还不快自己尝试一下)：https://regex101.com/]]></content>
      <categories>
        <category>正则表达式</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React Component lifecycle]]></title>
    <url>%2F2017%2F07%2F18%2Freact-life-cycle%2F</url>
    <content type="text"><![CDATA[React Component lifecycle最近刚开始使用react-native做项目，有一些心得，所以在这里发表一下。对没有接触过的技术和开发环境，了解核心component的生命周期是非常重要的。能够保证在写代码的过程中不容易犯错。 什么是component？根据React官方文档，React.component是一个抽象基类。能够让使用者将UI拆成各个独立地，可重用的component。常见的使用场景是继承它并提供一个render()方法。 12345class Greeting extends React.Component &#123; render() &#123; return &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;/h1&gt;; &#125;&#125; React lifecycle methods 上面这张图展示了一个React component的声明周期，从创建到销毁。接下来将逐步介绍以上各个方法并阐述什么时候使用使用它们。 Mount单词，字典上的意思是：”to get up on something above the level of the ground; especially:to seat oneself (as on a horse) for riding” 后面这段意思很形象，骑上马，可以跑了 :[ componentWillMount1componentWillMount() 当这个方法被调用的时候，说明你的component将要出现在屏幕上。渲染方法render将要被调用。在这个方法内你能干什么呢？ 答案是，你可能不能干太多的事情。因为当componentWillMount被调用的时候，还没有任何component能够使用，所以你也无法对DOM做任何事情。 另外，大部分初始化已经被component的constructor完成了(构造函数是你初始化默认值的最佳地方) 说到这里，你可能觉得这个方法真没用。但是，这里有一个例外场景，就是当你要在运行时为整个app初始化全局配置的时候, 并且要保证第一时间初始化方法被调用，这个方法是有特别有用的。这就意味着你的component中几乎99%以上都不会用到这个方法。 你可能会看到有人在这个方法里面启动AJAX calls或者执行一个Promise函数。不要这样做，下面会详细讲述原因。 常用场景：需要在运行时确定的App相关的配置是否能够使用setState: 否 componentDidMount1componentDidMount() 这个方法运行时，你的component已经加载上并已可使用。在这个方法里面你可以做很多事情，例如： 在一个已经渲染好的画板上绘制新的元素 添加event listeners 加载数据。为什么这个方法里面适合加载数据呢？因为你无法保证一个异步的请求在component加载完成之前完成，它是不确定的。在某些情况下，还可能会在component unmount之后请求的response才返回回来，而这个时候如果根据response来设置state的话就会产生异常。使用componentDidMount至少可以保证在结果返回之前是有component可以使用的（但是，如果response返回时不进行处理的话，也有可能会发生错误。本文提供一种ES6 promise的解决方案，请看make cancelable promise） 基本上，你可以做任何事情 常用场景：发起Ajax请求来加载数据是否能够使用setState: 是 componentWillReceiveProps1componentWillReceiveProps(nextProps) 这个方法被用来接收新的props。也许一些数据在parent component中加载并被传到当前compoent中。 当component能够对新的props做出任何动作之前，componentWillReceiveProps会被调用。 12345componentWillReceiveProps(nextProps) &#123; if(nextProps.text !=== this.props.text) &#123; this.setState(&#123;text: nextProps.text&#125;); &#125;&#125; 通过代码可以看到，在该方法中，我们可以同时访问当前props和nextProps。所以我们要做的就是： 检查props是否有变化 如果有变化，就做出相应的变化 注意 React也许会在props没有变化的时候调用该方法。所以总是判断props是否变化是有必要的。这种情况可能发生在parent component引起当前组件re-render。 React不会在component初始化，设置初始props的调用该方法 调用this.setState通常不会触发该方法 常用场景：针对props的变化做出相应的状态改变是否能够使用setState: 是 shouldComponentUpdate1shouldComponentUpdate(nextProps, nextState) 使用这个方法告诉React当前state或者props的变化是否会引起re-render。默认情况下，这个方法总是返回true，即需要re-render。如果你想要避免一些无意义或者纯属浪费的re-render，这个方法是你最好的选择。 P.S 根据react最新官方文档，目前，如果shouldComponentUpdate方法返回false,则componentWillUpdate(), render() 和 componentDidUpdate()方法都不会被调用。但是，在未来的react版本中， shouldComponentUpdate的返回值只具有参考价值而不是强制性的，所以方法返回false后component也有可能会re-render。 常用场景：控制component是否需要re-render是否能够使用setState: NO componentWillUpdate1componentWillUpdate(nextProps, nextState) 这个方法在re-render之前会被调用。这个方法跟 componentWillReceiveProps类似，只是你不能在该方法里调用this.setState。 如果你的component使用了shouldComponentUpdate并且当props变化的时候需要做一些事情，那么componentWillUpdate是一个不错的选择。 常用场景：在有shouldComponentUpdate方法的component中配合着用是否能够使用setState: NO componentDidUpdate1componentDidUpdate(prevProps, prevState) 在component 更新之后，使用这个方法来操作DOM。这个方法也是一个发送网络请求的好的选择之一，前提是需要判断当前props和prevProps相比是否产生了变化（如果props没有变化，则不需要发送网络请求） 常用场景：根据props或者state的变化，对DOM进行相应的变化是否能够使用setState: YES componentDidUpdate1componentWillUnmount() 这个方法会在component从屏幕上移除和销毁之前调用。在这个方法中，你需要进行任何必要的清理工作，比如取消network request，invalidate timers，remove event listeners或者清除任何在componentDidMount()中创建的DOM元素。 常用场景：清理一切需要必须清理的资源，事务或者事件是否能够使用setState: NO make cancelable promise使用Promise发起异步请求，等到异步请求返回的时候，component有可能已经unmounted了。这个时候在response的callback尝试setState会引发异常。怎么避免这种情况呢？ 感谢@istarkov提供了一种可取消的Promise的方案： 1234567891011121314151617const makeCancelable = (promise) =&gt; &#123; let hasCanceled_ = false; const wrappedPromise = new Promise((resolve, reject) =&gt; &#123; promise.then( val =&gt; hasCanceled_ ? reject(&#123;isCanceled: true&#125;) : resolve(val), error =&gt; hasCanceled_ ? reject(&#123;isCanceled: true&#125;) : reject(error) ); &#125;); return &#123; promise: wrappedPromise, cancel() &#123; hasCanceled_ = true; &#125;, &#125;;&#125;; 如何使用： 12345678910const cancelablePromise = makeCancelable( new Promise(r =&gt; component.setState(&#123;...&#125;&#125;)));cancelablePromise .promise .then(() =&gt; console.log('resolved')) .catch((reason) =&gt; console.log('isCanceled', reason.isCanceled));cancelablePromise.cancel(); // Cancel the promise]]></content>
      <categories>
        <category>javascript</category>
        <category>react</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 内购商品类型]]></title>
    <url>%2F2017%2F07%2F16%2Fios-iap-product-types%2F</url>
    <content type="text"><![CDATA[iOS 内购商品类型由于最近的项目有IAP，所以又重温了一遍iOS IAP的知识。在开发的过程中，发现网络上的各种文档都有，当然最详细的还是苹果官方IAP文档，但是苹果对每种类型介绍太官方(官话)，让刚开始看的人不太容易弄懂每种商品的区别。另外，深刻理解每种商品对后面的开发非常有帮助。所以，我觉得有必要说一下。 IAP的类型一共4种，接下来，我将对每一种进行通俗易懂的解释。 Consumable products (消费类型内购)苹果官方解释 Items that get used up over the course of running your app. Examples include minutes for a Voice over IP app and one-time services such as voice transcription. 这种产品类型应该大家都知道，很好懂。但是如果仅根据苹果的两个例子，这两个例子都是跟语音通话相关，一个没使用过任何内购的人还真不好理解。通俗来讲，就好比你去菜市场里边，你花X元买了Y个苹果，然后这个交易就完成了。 该类型的内购的例子很多，比如你玩游戏的时候，花了X元买了N个钻石；花X元兑换了N个虚拟币用于购买app中的某些虚拟服务等。 顾名思义，这种类型的商品的特点就是商品可消耗，可重复购买。每次购买的值一般都会叠加。如果买了后，用户不消耗，则一直存在用户相关的账号中。 Non-consumable products (非消费类型内购)该种类型的商品主要用于解锁app上的一些功能，或者游戏的某个关卡，又或者是获得某项主题之类的。总之就是当用户购买后，这个商品就一直生效，不需要重复购买。 Auto-renewable subscriptions (自动续费类型的内购)这种类型的商品有点跟Non-consumable商品类似，目的都是用户付钱后提供app中特定的某些功能。最大的不同是，该类商品有是有期限的。比如，某些app的VIP系统，这种系统一般按月计算，需要用户按照价格每月扣费。只有用户续费后，VIP才生效并且VIP相关的特权才能够生效。过期不续费，则VIP失效。 该类商品与Non-consumable products的区别是 有过期时间 可重复购买(系统自动续订) 该类商品的内容一般都会不断的更新 与Consumable products的区别是 这种商品买了就等于开始消耗，不用用户主动进行后续操作 有过期时间 苹果系统自动帮用户续费购买 Non-renewable subscriptions这种类型的商品跟Auto-renewable subscriptions的商品非常像，目的也是为了给用户提供持续服务的类型。最大的区别是，与该商品相关的续订的信息都由你的服务器保存和处理。简而言之，就是如果你选了Auto-renewable subscriptions，则苹果帮你搞定一切，包括用户的自动续订。但如果你选了Non-renewable subscriptions做为你提供的商品的类型，则你需要负责续订以及过期时间的管理，以及让用户购买的商品在用户所有的设备上可用（只要用户正确登录你的服务器）。哦，对了，还有恢复购买也需要你负责。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[什么是Javascript Hoisting？]]></title>
    <url>%2F2017%2F07%2F08%2Fjavascript-Hoisting%2F</url>
    <content type="text"><![CDATA[什么是Javascript hoisting?Javascript hoisting 国内一般翻译为变量提升。 Hoisting这个词是用来描述Javascript在执行上下文，尤其是创建和执行变量时时如何工作的。但是，hoisting使得Javascript的执行容易被误解。例如，hoisting通常被认为是把变量或者方法在运行时环境被物理地移动到代码的顶部，但是实际上却不是这样。实际上发生的是，变量或者方法的声明在编译时就被提前放入内存，而代码仍然放到原来的位置上。 接下来，通过几个例子来帮助理解 方法提升例子将方法的声明在任何代码执行之前放入内存的好处是能够在方法声明之前就能够使用它，因为它已经被提前放入内存里了。 123456789function catName(name) &#123; console.log("My cat's name is " + name);&#125;catName("Tigger");/*运行结果是: "My cat's name is Tigger"*/ 上面的代码是一个非常正常的代码。接下来，我们看一下如果把调用放到申明之前会发生什么。 12345678catName("Chloe");function catName(name) &#123; console.log("My cat's name is " + name);&#125;/*运行结果是: "My cat's name is Chloe"*/ 结果是，跟我们之前写的代码运行的结果一模一样。这是因为Javascript就是这么运行的。 变量提升例子1234num = 6;num + 7;var num; /* 只要num声明过，无论它在什么位置上，这个代码都运行正常*/ 注意: Javascript 只提升变量的声明，而不提升变量的定义。如果你在声明和定义之前试图获得变量的值，你会得到undefined。 12345678910var x = 1; // 初始化 xconsole.log(x + " " + y); // '1 undefined'，因为定义不会被提升var y = 2;// 下面这段代码的结果也是一样的var x = 1; // Initialize xvar y; // Declare yconsole.log(x + " " + y); // '1 undefined'y = 2; // Initialize y]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS memory types]]></title>
    <url>%2F2017%2F07%2F07%2Fios-memory-types%2F</url>
    <content type="text"><![CDATA[iOS memoryClean memoryclean memory are memories that can be recreated, on iOS it is memory of: system framework binary executable of your app memory mapped files Also notice this situation: when your app link to a framework, the clean memory will increase by the size of the framework binary. But most of time, only part of binary is really loaded in physical memory. Dirty memoryAll memory that is not clean memory is dirty memory, dirty memory can’t be recreated by system. When there is a memory pressure, system will unload some clean memory, when the memory is needed again, system will recreate them. But for dirty memory, system can’t unload them, and iOS has no swap mechanism, so dirty memory will always be kept in physical memory, till it reach a certain limit, then your App will be terminated and all memory for it is recycled by system. Virtual memoryvirtual memory = clean memory + dirty memory.That means virtual memory is all the memory your App want. Resident memoryresident memory = dirty memory + clean memory that loaded in physical memoryresident memory is the memory really loaded in your physical memory, it mean all the dirty memory and parts of your clean memory. ConclusionAt any time, this is always true:virtual memory == (clean memory + dirty memory) &gt; resident memory &gt; dirty memoryIf you are worrying about the physical memory your App is taking(which is the key reason your App is terminated due to low memory), you should mainly focus on resident memory.]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[查找素数]]></title>
    <url>%2F2017%2F07%2F07%2Ffind-primes%2F</url>
    <content type="text"><![CDATA[一个Eratosthenes 算法的实现质数的定义 质数（prime number）又称素数，有无限个。质数定义为在大于1的自然数中，除了1和它本身以外不再有其他因数，这样的数称为质数。 算法核心思想：这个算法的目的主要是找给定自然数N，找到N以内的所有质数。下面这个算法的实现的思想是：计算出质数P，然后将自然数N内所有能够整除P的数都剔除掉，之后计算出下一个质数，重复以上过程直到所有数都遍历过一次。 12345678910111213141516171819202122232425262728293031void findPrimes(bool *isPrimeFlags, const unsigned int n) &#123; isPrimeFlags[1] = false; for (unsigned int i = 2; i &lt; n; i++) &#123; isPrimeFlags[i] = true; &#125; //初始化，设置第一个素数为2 unsigned int p = 2; //设置j为p的平方的原因是 //1. 例如素数7，能够整除它的数为14,21,28,35,42,49,56,63,etc. 以此类推，设能够整除 //它的数为K, 则K = x * 7, 这里x &lt; 7时，比如2，在算法循环初始的时候，已经被设置为false了，则没必要再 //在素数为7的时候再比较一次了。 //2. p * p 如果大于n，则能够提前退出而不用遍历所有从2到N的素数。例如找100内的所有素数的时候，找到11的时候， //11 * 11 &gt; 100 就能够提前退出了。 unsigned int j = p * p; while (j &lt; n) &#123; //将所有能够整除p的数都设置为false while(j &lt; n) &#123; isPrimeFlags[j] = false; j += p; &#125; //找到下一个素数 while(!isPrimeFlags[++p] &amp;&amp; p &lt; n) &#123;&#125; j = p * p; &#125;&#125; Reference:https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[URL&URL encoding]]></title>
    <url>%2F2015%2F10%2F15%2FURL-URL-encoding%2F</url>
    <content type="text"><![CDATA[介绍当我们浏览网页的时候，其中涉及到不少技术。其中，有一项最基本的机制使得我们可以顺利的在浩瀚的互联网海洋中快速的定位到我们想要的资源并接收数据。这项技术是网页的根本，是形成互联网的基石。它就是URL。 URL 英文全名 Uniform resource locator，翻译过来就是统一资源标识符。例如，”http://www.baidu.com” 是一个URL。关于URL怎么定义，该遵守什么规则，是有着一套世界公认的规则的，第一版规则是在1994年诞生的。 一般URL语法我们先来看一个例子：https://jay:123456@www.example.com:8080/file;p=1?q=2#section2 分解该URL，我们能够获得以下信息： 组件名 数据 scheme https user jay password 123456 host address www.example.com port 8080 path file path parameter p=1 query parameter q=2 fragment section2 HTTP URL 语法HTTP URL的scheme通常组成为 Scheme: http或者https Path: 指定获取数据的路径 Query参数（可选） fragment参数（可选） Path 与 Path parameters其中，Path跟我们熟知的文件路径非常类似。Path通常是以一个“/”开头，每一个文件夹又都被一个”/”互相分隔，例如”/Study/URLSyntax/starter/first.docx”分为四个部分：”study”，”URLSyntax”，”starter”，”first.docx”。 每一个Path部分后都能够跟一个可选的参数(path parameters)部分，判断的根据是以”;”字符开始。参数可以有多个，并以”;”分隔。每个参数都有值，以”=”分隔，例如”/file;a=1”，定义了”file”这个path的参数为”a”，值为”1”。这些参数是很少用到的，但是他们是确实存在的。 Query在Path后面以”?”开始的部分就是Query了，Query包含一组以”&amp;”分隔的参数与数值对。参数及其数值以”=”分隔。例如，”?url=http://domain.tld/&amp;title=The title of a post”，定义了两个参数”url”和”title”，他们的值分别为”http://domain.tld“和”The title of a post”。Query 用的最多的情况是提交一个form的时候或者是搜索的时候。 FragmentFragment是用来定位到当前页面某一个具体位置的url部分。在url部分以”#”开始的部分为fragment。 URL encoding好了，聊完URL基本组成部分，接下来就要介绍URL encoding了。经常上网的同学一定对下面这种URL不陌生吧？https://www.baidu.com/s?ie=utf-8&amp;f=8&amp;rsv_bp=1&amp;rsv_idx=2&amp;tn=baiduhome_pg&amp;wd=%E7%BA%A2%E7%B1%B3note2&amp;rsv_spt=1&amp;oq=green&amp;rsv_pq=947783b70000 可以看到，该URL包括了一些神秘的字符，例如”wd=%E7%BA%A2%E7%B1%B3note2”，一般的人是无法读的。这就是被编码后的样子了。 为什么给URL 编码呢？原因很简单，因为如果允许任意字符的话，解析URL的任务将会非常艰巨而且效率低下，比如URL允许中文或者阿拉伯文。所以W3C组织就规定了一套协议，现在最新的应该是RFC 3986，有兴趣深入研究的同学推荐阅读。编码就是对URL每个部分，不允许出现的字符进行编码。那么允许的字符有哪些呢？如下所示：摘取自:https://en.wikipedia.org/wiki/Percent-encoding#Types_of_URI_characters. URL encoding介绍的差不多了，现在来讲讲URL encoding需要注意的问题。 URL encoding 陷阱RFC标准中没有指明使用哪种特定的编码格式来对url 进行编码。一般来说ASCII字符都是可以被使用的，但是对于保留字符(reserved characters)和非ASCII字符，我们必须考虑需要使用哪种编码方式来进行编码。最新的RFC标准是使用UTF-8来进行编码。但是，开发者也许也会遇到不是用UTF-8编码的时候。。。 对于HTTP URTs来说，空格符号在Path部分会被编码为”%20”，而”+”是不用被编码的。对于Query部分来说，空格符号会被编码为”+”或者”%20”，而”+”会被编码为”%2B”。 这样就意味着一个字符串在不同的部分就会被编码为不同的形式。例如”blue+light blue”字符串。我们来看一个具体的例子：http://example.com/blue+light%20blue?blue%2Blight+blue“。从这个例子可以看出如果对URL语法不熟悉的话，是无法对一个URL进行编码的。要对URL进行编码，就需要知道每一部分对应的保留字符是哪些而不是简单的对URL进行遍历并编码。 每个部分的保留字符 “?”在Query部分是不用被编码的 “/”在Query部分也是不用被编码的 “:@-._~!$&amp;’()*+,;=”在Path部分是不用被编码的 “/?:@-._~!$&amp;’()*+,;=”在fragment部分是不用被编码的 解码后的URL无法被正确分析通过一个例子来分析更清楚：”http://example.com/blue%2Fred%3Fand+green” 该URL有如下几个部分： 部分 值 scheme http host example.com path blue%2Fred%3Fand+green 解码后的path blue/red?and+green 分析后，很明显，我们是在找一个”blue/red?and+green”的资源，而不是找一个在blue文件夹下的”red?and+green”的资源。 如果我们首先对URL解码，然后再分析呢？解码后的URL:”http://example.com/blue/red?and+green” 部分 值 scheme http host example.com path blue/red query parameter name and+green 很明显，这个是错误的。这个例子告诉我们，分析并拆解一个URL必须要在解码之前进行。 解码后的URL有可能无法被编码回原来的格式如果对”http://example.com/blue%2Fred%3Fand+green“解码，你将得到”http://example.com/blue/red?and+green“，然后又进行编码，你将得到”http://example.com/blue/red?and+green“，因为这个是合法的URL不需要进行character escape。 参考原文：http://blog.lunatech.com/2009/02/03/what-every-web-developer-must-know-about-url-encoding]]></content>
      <categories>
        <category>http</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Objective-C Dynamic binding 研究]]></title>
    <url>%2F2015%2F09%2F22%2Fobjc-dynamic-binding%2F</url>
    <content type="text"><![CDATA[Objective-C Dynamic binding 研究对于习惯编写静态编程语言(C#/java/C++)的同学，初识Objective-C，可能会跟我有一样的迷惑。什么迷惑呀？请看下面这段oc的代码： 1234567891011121314151617181920212223242526272829303132333435@interface MyObject : NSObject+ (id)factoryMethod;-(NSString*)tell;@end@implementation MyObject+ (id)factoryMethodB &#123; return [[[self class] alloc] init]; &#125;- (NSString*)tell&#123; return @"I'm MyObject";&#125;@end@interface MyOtherObject : NSObject-(void)say;-(NSString*)tell;@end@implementation MyOtherObject-(void)say&#123; NSLog(@"Hello world");&#125;-(NSString*)tell&#123; return @"I'm MyOtherObject";&#125;@endvoid DoSometing()&#123; MyOtherObject *obj = [MyObject factoryMethod]; (1) NSLog(@"%@",[obj tell]); (2) [obj say]; (3)&#125; 代码顺利通过编译。调用DoSomething，运行到第(3)行时出错。先来看第（1）行，我打赌这行已经让只熟悉静态语言的程序员们不明白了，因为照理来说，MyObject的factoryMethod返回的是自己的实例，要是用别的语言编写，编译器第(1)行就报错了，因为类型不匹配呀。为什么OC的编译器不报错呢？不急，我们先来看看这个返回值id的定义： Objective-C provides a special type that can hold a pointer to anyobject you can construct with Objective-C—regardless of class. Thistype is called id, and can be used to make your Objective-Cprogramming generic. （大致意思就是id是一个与类型无关的指向任意对象的东东。能够让你OC编程泛型化。） 几个意思呢？其实id就是一个指针，但是它又不同于c/c++里面的void。void是指向内存中任意块的未知对象或者未知内容的。id很明确，它就是用来指向OC对象的。（关于void*是否能转换为OC对象这里暂时不讨论）。好了，这就解释了第(1)行的可行性。 运行到第二行的时候，NSLog输出: I’m MyObject 它居然正确的调用了MyObject的tell方法！这就要Dynamic binding（动态绑定）知识来解释了： Dynamic binding means that when we call a certain object’s method, and there are several implementations of that method, the right one is figured out at runtime. In Objective-C, this idea is used, but is also extended - you are permitted to send any message to any object. At first glance this may sound rather dangerous, but in fact this allows you a lot of flexibility. （大意是：OC的动态绑定的意思是OC扩展了Dynamic binding，使编程人员能够被允许发送任何消息给任何对象。咋一听这种扩展非常危险，但是实际上它带来了很大的灵活性！） 由于MyOtherObject*仅仅是声明一个指针，被赋予id。所以第(2)行怎么执行是在运行时决定的，所以[obj tell]也就顺理成章能够毫无错误的运行了。 第(3)行运行的时候，报错: unrecognized selector sent to instance 0x100400100 结合上面的知识，很容易判断，因为MyOtherObject有say方法，所以编译器通过。但是运行时，其实指针的内容是MyObject，MyObject并没有声明say方法，所以就报错了。 关于Dynamic binding还有个更有趣的例子，请看： 123456789101112131415161718192021@interface LinkedListNode : NSObject@property id data;@property LinkedListNode * child;@end@implementation LinkedListNode@endvoid DoSometing2()&#123; LinkedListNode *p = [[LinkedListNode alloc] init]; p.data = [MyOtherObject new]; LinkedListNode *child = [LinkedListNode new]; child.data = [MyObject new]; p.child = child; LinkedListNode *node; for (node = p; node != nil; node = node.child) &#123; [[node data] say]; &#125;&#125; 编译，没任何错误。运行，报的是跟上面(3)一样的错误。同样的原因，怎么办呢？你可能会想，太灵活了，太容易出错了。幸好，有解决的办法： 1234567891011121314LinkedListNode *p = [LinkedListNode new];p.data = [MyOtherObject new]; LinkedListNode *child = [LinkedListNode new]; child.data = [MyObject new]; p.child = child; LinkedListNode *node; for (node = p; node != nil; node = node.child) &#123; if ([[node data] respondsToSelector:@selector(say)]) &#123; [[node data] say]; &#125; &#125; &#125; 另外，还可以判断是否是某一特定类： 123if ([node isKindOfClass:[MyOtherObject class]]) &#123; [[node data] say]; &#125; 上述例子的factoryMethod的返回值id，苹果已经不推荐这么用了。苹果推荐返回instancetype。它跟id用法一样，但是主要是用在alloc, init或者类的工厂方法上的。它的好处是 编译器能够检测被调用的对象上是否能够反应传入的消息，如果不能，则发出警告。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>objective-c</tag>
      </tags>
  </entry>
</search>
